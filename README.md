# Интернет-магазин мебели SitDownPls (вёрстка)

Вёрстка основных страниц интернет-магазина мебели. Не является полноценным веб-приложением, основная цель проекта - вёрстка разных по уровню сложности компонентов страниц, потому линки не настроены, однако сборка осуществляется с помощью сборщика gulp. Свёрстанные страницы:

* Главная страница сайта */index.html*;
* Каталог товаров */catalog.html*;
* Карточка товара */product.html*;

## План запуска проекта

1. Установить все требуемые модули командой `npm i`;
2. Запустить сервер Gulp командой `npm run start`.

## План выполнения

1. Подключить Gulp:
    1.1. настроить конфигурационный файл **gulpfild.js**;
    1.2. сформировать схему src-директории проекта:
        - папка css (пустая);
        - папки img + img/svg (пустые);
        - папка js (+ файл **main.js**);
        - папка resources (внутри подпапка fonts для шрифтов + **favicon.svg**);
        - папка sass (+ файлы **main.sass**, **_normilize.sass**, **_reset.sass**, **_fonts.sass**, **_variables.sass**);
        - файл **index.html** с подготовленным !! (из шаблона): подключение стилей, шрифтов и иконки сайта;
    1.3. добавить доп. файлы в основной директории:
        - **.gitignore**;
        - **gulpfile.js** (скопировать из проекта "Аттестация по Веб-вёрстке PRO");
        - **package.json**;
    1.4. запустить `npm i` (установить все нужные node-модули);

2. Подключить шрифты:
    2.1. можно подключить их через sass путем создания файла **srs/sass/_fonts.sass** и импортом в **src/sass/main.sass**:
        - соблюдать порядок подключения, чтобы шрифты были первыми, причем до переменных, где можно указать главный шрифт страницы;
    2.2. а можно добавить файл **src/css/fonts.css**:
        - галп будет собирать все файлы css в один, и (возможно!) шрифты будут подключаться первыми;
    2.3. добавить в **index.html** после `<head><title>` линки на все шрифты:
        - сначала на шрифты woff2:
        `<link rel="prefetch" href="fonts/TTFirsNeue-Regular.woff2" as="font" type="font/woff2" crossorigin>`
        - потом на шрифты woff (аналогично);
        - причем подумать, `prefetch` или все-таки `preload`, т.к. будем подключать шрифты также через `@font-face`, и будем искать там локальный шрифт, установленный ранее;

3. Разбить весь HTML-файл на мелкие независимые блоки:
    3.1. блок с логотипом;
    3.2. блок с инпутом + маской;
    3.3. блок с кнопкой;
    3.4. блок со стандартным текстом;
    3.5. блок со стандартным заголовком;
    3.6. блок с фотографией/изображением;
    3.7. блок с абсолютно спозиционированным элементом (например, тегом или крестиком закрытия);
    3.8. блок со ссылкой и SVG-картинкой внутри;
    3.9. блок с поисковой строкой (абсолютное позиционирование);
    3.10. блок с псевдоэлементами-иконкой;
    3.11. более сложные блоки, состоящие из выстроенных ранее мелких блоков;
    3.12. блоки с иконками социальных сетей для футеров;
    3.13. и т.д.

4. способ ведения SASS:
    4.1. в отдельный файл **_variables.sass** собрать все повторяющиеся цвета + размеры + шрифты и т.д.;
    4.2. для мелких повторяющихся независимых блоков создать общий файл **_common.sass**;
    4.3. для средних блоков, состоящих из мелких элементов, завести отдельные файлы **_module.sass;**
    4.4. в каждом тематическом файле к нужному изменяющемуся блоку добавлять в конце медиазапрос `@media (max-width:...)`;
    4.5. общий файл **main.sass** выстроить сбором общего блока и блоков модулей воедино;

5. добавить в конце все визуальные эффекты по:
    5.1. кнопкам;
    5.2. ссылкам;
    5.3. иконкам;
    5.4. инпутам;

6. план создания собственного селекта с выпадающими чекбоксами:
    6.1. интерфейс (всем элементам обязательно давать кастомное имя и его наследников по технологии БЭМ! Это важно!):
        - создать контейнерный элемент с кастомным классом и одноименным id;
        - добавить этому контейнеру data-атрибуты:
            - data-placeholder="содержимое плейсхолдера при отсутствии выбранных значений";
            - data-value="";
              `<div class="select-check custom-select" id="custom-select" data-placeholder="Выберите..." data-value="">`
        - внутрь контейнера добавить 2 элемента: шапка (строка с выбранными значениями) с таб-индексом для возможности фокусирования и выпадающее меню:
          ```<div class="select-check custom-select" id="custom-select" data-placeholder="Выберите..." data-value="">
            <div class="select-check__header custom-select__header" tabindex="0">
            <div class="select-check__body custom-select__body">```
        - внутрь шапки вставить 2 элемента: строка с выбранным значением и блок с иконкой открытия/закрытия:
          ```<div class="select-check__header custom-select__header" tabindex="0">
            <span class="select-check__current custom-select__current">Элемент 1</span>
            <div class="select-check__icon custom-select__icon">...</div> - внутрь добавить любой блок с изображением;```
        - внутрь выпадающего меню добавить элементы по принципу:
            - контейнер с элементом (выставить таб-индекс для фокусировки):
              ```<div class="select-check__body custom-select__body">
                <div class="select-check__item custom-select__item" tabindex="0">```
            - внутрь контейнера с элементом добавить блок .checkbox с чекбоксом (input с уникальным id) и подписью (label с атрибутом name, используемым в дальнейшем для вывода выбранных значений):
              ```<div class="select-check__item custom-select__item" tabindex="0">
                <div class="checkbox select-check__checkbox filters-categories__checkbox">
                  <input type="checkbox" class="select-check__input custom-select__input" id="custom-select-1">
                  <label for="custom-select-1" class="select-check__label custom-select__label" name="sofa">Подпись</label>```
            - разместить требуемое количество элементов;

        - *TODO*: добавить настройку при фокусировке именно инпутов - когда инпут фокусируется, через js-скрипт навешивать всему элементу меню класс выделения, а у самого контейнера с элементом `select-check__item` убрать `tabindex`, т.к. сейчас происходит двойная фокусировка - сперва элемент, затем инпут внутри него;
        - *TODO*: сделать так, чтобы при клике в document проверялась не только `target`, а еще и возможная svg картинка. Т.к. иначе при таком таргете не закрывается менюшка. Возможно, лучше переделать на бэкграунд имэдж, тогда внутри селекта не будет никаких неуправляемых свг-объектов;
        - *TODO*: добавлять единый общий класс для всех селектов - и инпутов, и чеков, чтобы не перебирать дважды цикл всех элементов в `document.onclick`;

    6.2. тело (организация обработчиков, см. **catalogElements.js**) - *TODO*:
        - создать функцию, которая будет добавлять содержимое в блок по передаваемому списку элементов;
        - будет назначать им имена в соответствии с кодом класса селекта, например `#custom-select__...`;
        - при загрузке добавить выбранные элементы в шапку инпута вместо `placeholder`, либо, если ничего не выбрано, оставить `placeholder` (нужна инициализация объекта при создании с уже выбранными по умолчанию элементами);
        - добавить обработку кликов на шапке Enter/Space (нужно, чтобы меню разворачивалось);
